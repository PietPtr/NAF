/* AUTOMATICALLY GENERATED VERILOG-2001 SOURCE CODE.
** GENERATED BY CLASH 1.6.5. DO NOT MODIFY.
*/
`timescale 100fs/100fs
module main
    ( // Inputs
      input  clock // clock
    , input  reset // reset
    , input  enable // enable
    , input  udp_rx_valid
    , input  udp_rx_first
    , input  udp_rx_last
    , input [7:0] udp_rx_payload
    , input  udp_rx_last_be
    , input  udp_tx_ready

      // Outputs
    , output wire  udp_rx_ready
    , output wire  udp_tx_valid
    , output wire  udp_tx_first
    , output wire  udp_tx_last
    , output wire [7:0] udp_tx_payload
    );
  reg  c$app_arg = 1'b0;
  // ../clash/UDP.hs:(44,1)-(45,45)
  reg [20:0] c$ds_app_arg = {12'd0,   {1'b0,8'bxxxxxxxx}};
  wire [10:0] result;
  wire [31:0] result_0;
  wire [7:0] c$case_alt;
  wire [0:0] c$case_alt_0;
  reg [0:0] c$case_alt_1;
  wire [0:0] c$case_alt_2;
  reg [0:0] c$case_alt_3;
  wire [0:0] c$case_alt_4;
  wire [8:0] c$case_alt_5;
  reg [8:0] c$case_alt_6;
  reg [8:0] c$case_alt_7;
  wire [8:0] c$case_alt_8;
  // ../clash/UDP.hs:60:1-20
  wire [11:0] cycle_counter1;
  reg [10:0] c$app_arg_0 = {1'b0,   1'b0,   1'b0,   8'd0};
  wire [12:0] udp;
  wire [8:0] c$case_alt_selection_1;
  wire [8:0] c$case_alt_selection_4;
  wire [7:0] c$case_alt_selection_8;
  wire [8:0] c$case_alt_selection_11;
  wire [7:0] c$case_alt_selection_15;
  wire [8:0] c$case_alt_selection_18;
  wire [8:0] c$case_alt_selection_21;
  wire [7:0] c$case_alt_selection_25;
  wire [11:0] udp_0;
  wire [10:0] udp_tx;

  assign udp = {{udp_rx_valid,   udp_rx_first,
                 udp_rx_last,   udp_rx_payload,
                 udp_rx_last_be},   udp_tx_ready};

  // register begin
  always @(posedge clock or  posedge  reset) begin : c$app_arg_register
    if ( reset) begin
      c$app_arg <= 1'b0;
    end else if (enable) begin
      c$app_arg <= udp[0:0];
    end
  end
  // register end

  // register begin
  always @(posedge clock or  posedge  reset) begin : c$ds_app_arg_register
    if ( reset) begin
      c$ds_app_arg <= {12'd0,   {1'b0,8'bxxxxxxxx}};
    end else if (enable) begin
      c$ds_app_arg <= result_0[31:11];
    end
  end
  // register end

  assign result = result_0[10:0];

  assign result_0 = {{cycle_counter1 + 12'd1,
                      c$case_alt_5},   {(c$case_alt_4),
                                        (c$case_alt_2),   (c$case_alt_0),
                                        c$case_alt}};

  assign c$case_alt_selection_1 = c$ds_app_arg[8:0];

  assign c$case_alt = c$case_alt_selection_1[8:8] ? ((c$ds_app_arg[7:0])) : 8'b11111111;

  assign c$case_alt_selection_4 = c$ds_app_arg[8:0];

  assign c$case_alt_0 = c$case_alt_selection_4[8:8] ? c$case_alt_1 : 1'b0;

  assign c$case_alt_selection_8 = c$ds_app_arg[7:0];

  always @(*) begin
    case(c$case_alt_selection_8)
      8'd0 : c$case_alt_1 = 1'b1;
      default : c$case_alt_1 = 1'b0;
    endcase
  end

  assign c$case_alt_selection_11 = c$ds_app_arg[8:0];

  assign c$case_alt_2 = c$case_alt_selection_11[8:8] ? c$case_alt_3 : 1'b0;

  assign c$case_alt_selection_15 = c$ds_app_arg[7:0];

  always @(*) begin
    case(c$case_alt_selection_15)
      8'd32 : c$case_alt_3 = 1'b1;
      default : c$case_alt_3 = 1'b0;
    endcase
  end

  assign c$case_alt_selection_18 = c$ds_app_arg[8:0];

  assign c$case_alt_4 = c$case_alt_selection_18[8:8] ? 1'b1 : 1'b0;

  assign c$case_alt_selection_21 = c$ds_app_arg[8:0];

  assign c$case_alt_5 = c$case_alt_selection_21[8:8] ? c$case_alt_6 : c$case_alt_7;

  assign c$case_alt_selection_25 = c$ds_app_arg[7:0];

  always @(*) begin
    case(c$case_alt_selection_25)
      8'd0 : c$case_alt_6 = {1'b0,8'bxxxxxxxx};
      default : c$case_alt_6 = c$case_alt_8;
    endcase
  end

  always @(*) begin
    case(cycle_counter1)
      12'd0 : c$case_alt_7 = {1'b1,8'd32};
      default : c$case_alt_7 = {1'b0,8'bxxxxxxxx};
    endcase
  end

  assign c$case_alt_8 = (c$app_arg == 1'b1) ? {1'b1,c$ds_app_arg[7:0] - 8'd1} : c$ds_app_arg[8:0];

  assign cycle_counter1 = c$ds_app_arg[20:9];

  // register begin
  always @(posedge clock or  posedge  reset) begin : c$app_arg_0_register
    if ( reset) begin
      c$app_arg_0 <= {1'b0,   1'b0,   1'b0,   8'd0};
    end else if (enable) begin
      c$app_arg_0 <= result;
    end
  end
  // register end

  assign udp_0 = {1'b1,   c$app_arg_0};

  assign udp_rx_ready = udp_0[11:11];

  assign udp_tx = udp_0[10:0];

  assign udp_tx_valid = udp_tx[10:10];

  assign udp_tx_first = udp_tx[9:9];

  assign udp_tx_last = udp_tx[8:8];

  assign udp_tx_payload = udp_tx[7:0];


endmodule

