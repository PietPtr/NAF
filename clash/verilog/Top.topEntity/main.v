/* AUTOMATICALLY GENERATED VERILOG-2001 SOURCE CODE.
** GENERATED BY CLASH 1.6.5. DO NOT MODIFY.
*/
`timescale 100fs/100fs
module main
    ( // Inputs
      input  clock // clock
    , input  reset // reset
    , input  enable // enable
    , input  udp_rx_valid
    , input  udp_rx_first
    , input  udp_rx_last
    , input [31:0] udp_rx_payload
    , input [3:0] udp_rx_last_be
    , input  udp_tx_ready

      // Outputs
    , output wire  udp_rx_ready
    , output wire  udp_tx_valid
    , output wire  udp_tx_first
    , output wire  udp_tx_last
    , output wire [31:0] udp_tx_payload
    , output wire [3:0] udp_tx_last_be
    );
  reg  c$app_arg = 1'b0;
  // ../clash/UDP.hs:(45,1)-(46,45)
  reg [19:0] c$ds_app_arg = {8'd0,   12'd0};
  wire [38:0] result;
  // ../clash/UDP.hs:55:1-20
  wire [0:0] c$last_app_arg;
  wire [7:0] c$case_alt;
  wire [7:0] c$case_alt_0;
  wire [7:0] c$app_arg_0;
  reg [0:0] c$app_arg_1;
  wire [58:0] result_0;
  // ../clash/UDP.hs:55:1-20
  wire  last;
  // ../clash/UDP.hs:55:1-20
  wire [7:0] payload_counter1;
  reg [38:0] c$app_arg_2 = {1'b0,   1'b0,   1'b0,   32'd0,   4'd0};
  wire [39:0] udp;
  wire [39:0] udp_0;
  wire [38:0] udp_tx;

  assign udp = {{udp_rx_valid,   udp_rx_first,
                 udp_rx_last,   udp_rx_payload,
                 udp_rx_last_be},   udp_tx_ready};

  // register begin
  always @(posedge clock or  posedge  reset) begin : c$app_arg_register
    if ( reset) begin
      c$app_arg <= 1'b0;
    end else if (enable) begin
      c$app_arg <= udp[0:0];
    end
  end
  // register end

  // register begin
  always @(posedge clock or  posedge  reset) begin : c$ds_app_arg_register
    if ( reset) begin
      c$ds_app_arg <= {8'd0,   12'd0};
    end else if (enable) begin
      c$ds_app_arg <= result_0[58:39];
    end
  end
  // register end

  assign result = result_0[38:0];

  assign c$last_app_arg = (payload_counter1 >= 8'd40) ? 1'b1 : 1'b0;

  assign c$case_alt = (last == 1'b1) ? 8'd0 : payload_counter1;

  assign c$case_alt_0 = (last == 1'b0) ? (payload_counter1 + 8'd1) : c$case_alt;

  assign c$app_arg_0 = (c$app_arg == 1'b1) ? c$case_alt_0 : payload_counter1;

  always @(*) begin
    case(payload_counter1)
      8'd0 : c$app_arg_1 = 1'b1;
      default : c$app_arg_1 = 1'b0;
    endcase
  end

  assign result_0 = {{c$app_arg_0,
                      c$ds_app_arg[11:0] + 12'd1},   {1'b1,
                                                      (((c$app_arg_1)) & c$app_arg) & 1'b1,   last,
                                                      {24'b000000000000000000000000,((payload_counter1))},
                                                      4'b1111}};

  assign last = (((c$last_app_arg)) & c$app_arg) & 1'b1;

  assign payload_counter1 = c$ds_app_arg[19:12];

  // register begin
  always @(posedge clock or  posedge  reset) begin : c$app_arg_2_register
    if ( reset) begin
      c$app_arg_2 <= {1'b0,   1'b0,   1'b0,   32'd0,   4'd0};
    end else if (enable) begin
      c$app_arg_2 <= result;
    end
  end
  // register end

  assign udp_0 = {1'b1,   c$app_arg_2};

  assign udp_rx_ready = udp_0[39:39];

  assign udp_tx = udp_0[38:0];

  assign udp_tx_valid = udp_tx[38:38];

  assign udp_tx_first = udp_tx[37:37];

  assign udp_tx_last = udp_tx[36:36];

  assign udp_tx_payload = udp_tx[35:4];

  assign udp_tx_last_be = udp_tx[3:0];


endmodule

